// COMP1521 20T3 Assignment 1: mips_sim -- a MIPS simulator
// starting point code v0.1 - 13/10/20


// PUT YOUR HEADER COMMENT HERE

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <errno.h>

#define MAX_LINE_LENGTH 256
#define INSTRUCTIONS_GROW 64


// ADD YOUR #defines HERE
//The following are the type of define we going to use as instruction
#define ADD  0b100000
#define SUB  0b100010
#define SLT  0b101010
#define MUL  0b000010
#define BEQ  0b000100
#define BNE  0b000101
#define ADDI 0b001000
#define ORI  0b001101
#define LUI  0b001111
#define SYS  0b001100
#define AND  0b100100
#define OR   0b100101
#define P    0b11111000000   //make sure that last 11 bits are correct, so that the instruction will be valid


void execute_instructions(int n_instructions,
                          uint32_t instructions[n_instructions],
                          int trace_mode);
char *process_arguments(int argc, char *argv[], int *trace_mode);
uint32_t *read_instructions(char *filename, int *n_instructions_p);
uint32_t *instructions_realloc(uint32_t *instructions, int n_instructions);


// ADD YOUR FUNCTION PROTOTYPES HERE
//add instruction
void add(uint32_t types_of_instruct, int* storeage, int trace_mode);
//sub instruction
void sub(uint32_t types_of_instruct, int* storeage, int trace_mode);
//slt instruction
void slt(uint32_t types_of_instruct, int* storeage, int trace_mode);
//mul instruction
void mul(uint32_t types_of_instruct, int* storeage, int trace_mode);
//beq instruction
void beq(uint32_t types_of_instruct, int* storeage, int* pc, int trace_mode);
//bne instruction
void bne(uint32_t types_of_instruct, int* storeage, int* pc, int trace_mode);
//addi instruction
void addi(uint32_t types_of_instruct, int* storeage, int trace_mode);
//ori instruction
void ori(uint32_t types_of_instruct, int* storeage, int trace_mode);
//lui instruction
void lui(uint32_t types_of_instruct, int* storeage, int trace_mode);
//syscall instruction
void syscall(int* storeage, int trace_mode);
//error instruction
void error();

void instructions_actions(int pc, uint32_t* instructions);

// YOU SHOULD NOT NEED TO CHANGE MAIN

int main(int argc, char *argv[]) {
    int trace_mode;

    char *filename = process_arguments(argc, argv, &trace_mode);

    int n_instructions;
    uint32_t *instructions = read_instructions(filename, &n_instructions);
    
    execute_instructions(n_instructions, instructions, trace_mode);
    

    free(instructions);
    return 0;
}


// simulate execution of  instruction codes in  instructions array
// output from syscall instruction & any error messages are printed
//
// if trace_mode != 0:
//     information is printed about each instruction as it executed
//
// execution stops if it reaches the end of the array

void execute_instructions(int n_instructions,
                          uint32_t instructions[n_instructions],
                          int trace_mode) {
    // REPLACE CODE BELOW WITH YOUR CODE

    int pc = 0;
    
    int* point_to_pc = &pc;
    
    int storeage[32] = {0};
    
    while (pc < n_instructions) {
        if (trace_mode) {
            printf("%d: 0x%08X ", pc, instructions[pc]);
        }
        
        uint32_t types_of_instruct = instructions[pc];
        
        if (((types_of_instruct >> 26) & P) != 0 || types_of_instruct == 0) {
            error();
            break;
        }
        if (((types_of_instruct >> 26) | 0) == 0) {
            if ((types_of_instruct << 26 >> 26) == SYS) {
                syscall(storeage, trace_mode);
                if (storeage[2] > 31) {break;}
            } else if ((types_of_instruct << 26 >> 26) == ADD){
                add(types_of_instruct, storeage, trace_mode);
            } else if ((types_of_instruct << 26 >> 26) == SUB) {
                sub(types_of_instruct, storeage, trace_mode);
            } else if ((types_of_instruct << 26 >> 26) == SLT) {
                slt(types_of_instruct, storeage, trace_mode);
            }
        } else {
            if ((types_of_instruct >> 26) == ADDI){
                addi(types_of_instruct, storeage, trace_mode);
            } else if ((types_of_instruct << 26 >> 26) == MUL) {
                mul(types_of_instruct, storeage, trace_mode);
            } else if ((types_of_instruct >> 26) == ORI) { 
                ori(types_of_instruct, storeage, trace_mode);
            } else if ((types_of_instruct >> 26) == LUI) {
                lui(types_of_instruct, storeage, trace_mode);
            } else if ((types_of_instruct >> 26) == BEQ) {
                beq(types_of_instruct, storeage, point_to_pc, trace_mode);
            } else if ((types_of_instruct >> 26) == BNE) {
                bne(types_of_instruct, storeage, point_to_pc, trace_mode);
            }
        }
        
        if ((pc < 0) || (pc > n_instructions)) {
            printf("Illegal branch to address before instructions: PC = %d\n", *point_to_pc+1);
            return;
        }
        pc++;
    }  
}

// ADD YOUR FUNCTIONS HERE
void add(uint32_t types_of_instruct, int* storeage, int trace_mode) {
    uint32_t s = types_of_instruct << 6 >> 27;
    uint32_t t = types_of_instruct << 11 >> 27;
    uint32_t d = types_of_instruct << 16 >> 27;
    int r = storeage[s] + storeage[t];
    if (d != 0) {
        storeage[d] = r;
    }
    if (trace_mode) {
        printf("add  $%d, $%d, $%d\n", d, s, t);
        printf(">>> $%d = %d\n", d, r);
    }
}


void sub(uint32_t types_of_instruct, int* storeage, int trace_mode) {
    uint32_t s = types_of_instruct << 6 >> 27;
    uint32_t t = types_of_instruct << 11 >> 27;
    uint32_t d = types_of_instruct << 16 >> 27;
    int r = storeage[s] - storeage[t];
    if (d != 0) {
        storeage[d] = r;
    }
    if (trace_mode) {
        printf("sub $%d, $%d, $%d\n", d, s, t);
        printf(">>> $%d = %d\n", d, r);
    }
}


void slt(uint32_t types_of_instruct, int* storeage, int trace_mode) {
    uint32_t s = types_of_instruct << 6 >> 27;
    uint32_t t = types_of_instruct << 11 >> 27;
    uint32_t d = types_of_instruct << 16 >> 27; 
    int r = 0;
    if (storeage[s] < storeage[t]) r = 1;
    if (d != 0) {
        storeage[d] = r;
    }
    if (trace_mode) {
        printf("slt  $%d, $%d, $%d\n", d, s, t);
        printf(">>> $%d = %d\n", d, r);
    }
}


//////////////////////////////////////////////////////////////////////////
void addi(uint32_t types_of_instruct, int* storeage, int trace_mode) {
    int16_t s = (int16_t)(types_of_instruct << 6 >> 27);
    int16_t t = (int16_t)(types_of_instruct << 11 >> 27);
    int16_t I = (int16_t)(types_of_instruct << 16 >> 16);
    if (s != 0) storeage[t] = I + storeage[s];
    if (trace_mode) {
        printf("addi $%d, $%d, %d\n", t, s, I);
        printf(">>> $%d = %d\n", t, storeage[t]);
    }
}


void ori(uint32_t types_of_instruct, int* storeage, int trace_mode) {
    int16_t s = (int16_t)(types_of_instruct << 6 >> 27);
    int16_t t = (int16_t)(types_of_instruct << 11 >> 27);
    int16_t I = (int16_t)(types_of_instruct << 16 >> 16);
    storeage[t] = storeage[s] | I;
    if (trace_mode) {
        printf("ori  $%d, $%d, %d\n", t, s, I);
        printf(">>> $%d = %d\n", t, storeage[t]);        
    }
}


void lui(uint32_t types_of_instruct, int* storeage, int trace_mode) {
    int16_t t = (int16_t)(types_of_instruct << 11 >> 27);
    int16_t I = (int16_t)(types_of_instruct << 16 >> 16);
    if (t != 0) {
        storeage[t] = storeage[t] | I;
    }
    storeage[t] = I << 16; 
    if (trace_mode) {
        printf("lui  $%d, %d\n", t, I);
        printf(">>> $%d = %d\n", t, storeage[t]);
    }
}


void mul(uint32_t types_of_instruct, int* storeage, int trace_mode) {
    uint32_t s = types_of_instruct << 6 >> 27;
    uint32_t t = types_of_instruct << 11 >> 27;
    uint32_t d = types_of_instruct << 16 >> 27; 
    int r = storeage[s] * storeage[t];
    if (d != 0) storeage[d] = r;
    if (trace_mode) {
        printf("mul  $%d, $%d, $%d\n", d, s, t);
        printf(">>> $%d = %d\n", d, r);
    }
}


void beq(uint32_t types_of_instruct, int* storeage, int* pc, int trace_mode) {
    int16_t s = (int16_t)(types_of_instruct << 6 >> 27);
    int16_t t = (int16_t)(types_of_instruct << 11 >> 27);
    int16_t I = (int16_t)(types_of_instruct << 16 >> 16);
    if (trace_mode) {
        printf("bne $%d, $%d, %d\n", s, t, I);
        if (storeage[s] == storeage[t]) {
            *pc+=I;
            printf(">>> branch taken to PC = %d\n", *pc);
            *pc-=1;
        } else {
            printf(">>> branch not taken\n");
        }
    } else {
        if (storeage[s] == storeage[t]) {
            *pc+=I;
            *pc-=1;
        }
    }
}


void bne(uint32_t types_of_instruct, int* storeage, int* pc, int trace_mode) {
    int16_t s = (int16_t)(types_of_instruct << 6 >> 27);
    int16_t t = (int16_t)(types_of_instruct << 11 >> 27);
    int16_t I = (int16_t)(types_of_instruct << 16 >> 16);
    if (trace_mode) {
        printf("bne  $%d, $%d, %d\n", s, t, I);
        if (storeage[s] != storeage[t]) {
            *pc+=I;
            printf(">>> branch taken to PC = %d\n", *pc);
            *pc-=1;
        } else {
            printf(">>> branch not taken\n");
        }
    } else {
        if (storeage[s] != storeage[t]) {
            *pc+=I;
            *pc-=1;
        }
    }
}


void error() {
    printf("invalid instruction code\n");
}


void syscall(int* storeage, int trace_mode) {
    if (trace_mode) {
        printf("syscall\n");
        printf(">>> syscall %d\n", storeage[2]);
        
        if (storeage[2] == 1) {
            printf("<<< %d\n", storeage[4]);
            return;
        } else if (storeage[2] == 10) {
            exit(0);
        } else if (storeage[2] == 11) {
            printf("<<< %c\n", storeage[4]);
            return;
        } else {
            printf("Unknown system call: %d\n", storeage[2]);
            exit(-1);
        }
    } else {
        if (storeage[2] == 1) {
            printf("%d", storeage[4]);
            return;
        } else if (storeage[2] == 10) {
            exit(0);
        } else if(storeage[2] == 11) {
            printf("%c", storeage[4]);
            return;
        } else if (storeage[2] > 31) {
            printf("Unknown system call: %d\n", storeage[2]);
            exit(-1);
        }
    }
}


// YOU DO NOT NEED TO CHANGE CODE BELOW HERE


// check_arguments is given command-line arguments
// it sets *trace_mode to 0 if -r is specified
//          *trace_mode is set to 1 otherwise
// the filename specified in command-line arguments is returned

char *process_arguments(int argc, char *argv[], int *trace_mode) {
    if (
        argc < 2 ||
        argc > 3 ||
        (argc == 2 && strcmp(argv[1], "-r") == 0) ||
        (argc == 3 && strcmp(argv[1], "-r") != 0)) {
        fprintf(stderr, "Usage: %s [-r] <file>\n", argv[0]);
        exit(1);
    }
    *trace_mode = (argc == 2);
    return argv[argc - 1];
}


// read hexadecimal numbers from filename one per line
// numbers are return in a malloc'ed array
// *n_instructions is set to size of the array

uint32_t *read_instructions(char *filename, int *n_instructions_p) {
    FILE *f = fopen(filename, "r");
    if (f == NULL) {
        fprintf(stderr, "%s: '%s'\n", strerror(errno), filename);
        exit(1);
    }

    uint32_t *instructions = NULL;
    int n_instructions = 0;
    char line[MAX_LINE_LENGTH + 1];
    while (fgets(line, sizeof line, f) != NULL) {

        // grow instructions array in steps of INSTRUCTIONS_GROW elements
        if (n_instructions % INSTRUCTIONS_GROW == 0) {
            instructions = instructions_realloc(instructions, n_instructions + INSTRUCTIONS_GROW);
        }

        char *endptr;
        instructions[n_instructions] = strtol(line, &endptr, 16);
        if (*endptr != '\n' && *endptr != '\r' && *endptr != '\0') {
            fprintf(stderr, "%s:line %d: invalid hexadecimal number: %s",
                    filename, n_instructions + 1, line);
            exit(1);
        }
        n_instructions++;
    }
    fclose(f);
    *n_instructions_p = n_instructions;
    // shrink instructions array to correct size
    instructions = instructions_realloc(instructions, n_instructions);
    return instructions;
}


// instructions_realloc is wrapper for realloc
// it calls realloc to grow/shrink the instructions array
// to the speicfied size
// it exits if realloc fails
// otherwise it returns the new instructions array
uint32_t *instructions_realloc(uint32_t *instructions, int n_instructions) {
    instructions = realloc(instructions, n_instructions * sizeof *instructions);
    if (instructions == NULL) {
        fprintf(stderr, "out of memory");
        exit(1);
    }
    return instructions;
}
